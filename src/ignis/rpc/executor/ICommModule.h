/**
 * Autogenerated by Thrift Compiler (0.14.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ICommModule_H
#define ICommModule_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "ICommModule_types.h"

namespace ignis { namespace rpc { namespace executor {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class ICommModuleIf {
 public:
  virtual ~ICommModuleIf() {}
  virtual void openGroup(std::string& _return) = 0;
  virtual void closeGroup() = 0;
  virtual void joinToGroup(const std::string& id, const bool leader) = 0;
  virtual void joinToGroupName(const std::string& id, const bool leader, const std::string& name) = 0;
  virtual bool hasGroup(const std::string& name) = 0;
  virtual void destroyGroup(const std::string& name) = 0;
  virtual void destroyGroups() = 0;
  virtual int8_t getProtocol() = 0;
  virtual void getPartitions(std::vector<std::string> & _return, const int8_t protocol) = 0;
  virtual void getPartitions2(std::vector<std::string> & _return, const int8_t protocol, const int64_t minPartitions) = 0;
  virtual void setPartitions(const std::vector<std::string> & partitions) = 0;
  virtual void setPartitions2(const std::vector<std::string> & partitions, const  ::ignis::rpc::ISource& src) = 0;
  virtual void newEmptyPartitions(const int64_t n) = 0;
  virtual void newEmptyPartitions2(const int64_t n, const  ::ignis::rpc::ISource& src) = 0;
  virtual void driverGather(const std::string& group, const  ::ignis::rpc::ISource& src) = 0;
  virtual void driverGather0(const std::string& group, const  ::ignis::rpc::ISource& src) = 0;
  virtual void driverScatter(const std::string& group, const int64_t partitions) = 0;
  virtual void driverScatter3(const std::string& group, const int64_t partitions, const  ::ignis::rpc::ISource& src) = 0;
  virtual int32_t enableMultithreading(const std::string& group) = 0;
  virtual void send(const std::string& group, const int64_t partition, const int64_t dest, const int32_t thread) = 0;
  virtual void recv(const std::string& group, const int64_t partition, const int64_t source, const int32_t thread) = 0;
};

class ICommModuleIfFactory {
 public:
  typedef ICommModuleIf Handler;

  virtual ~ICommModuleIfFactory() {}

  virtual ICommModuleIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(ICommModuleIf* /* handler */) = 0;
};

class ICommModuleIfSingletonFactory : virtual public ICommModuleIfFactory {
 public:
  ICommModuleIfSingletonFactory(const ::std::shared_ptr<ICommModuleIf>& iface) : iface_(iface) {}
  virtual ~ICommModuleIfSingletonFactory() {}

  virtual ICommModuleIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(ICommModuleIf* /* handler */) {}

 protected:
  ::std::shared_ptr<ICommModuleIf> iface_;
};

class ICommModuleNull : virtual public ICommModuleIf {
 public:
  virtual ~ICommModuleNull() {}
  void openGroup(std::string& /* _return */) {
    return;
  }
  void closeGroup() {
    return;
  }
  void joinToGroup(const std::string& /* id */, const bool /* leader */) {
    return;
  }
  void joinToGroupName(const std::string& /* id */, const bool /* leader */, const std::string& /* name */) {
    return;
  }
  bool hasGroup(const std::string& /* name */) {
    bool _return = false;
    return _return;
  }
  void destroyGroup(const std::string& /* name */) {
    return;
  }
  void destroyGroups() {
    return;
  }
  int8_t getProtocol() {
    int8_t _return = 0;
    return _return;
  }
  void getPartitions(std::vector<std::string> & /* _return */, const int8_t /* protocol */) {
    return;
  }
  void getPartitions2(std::vector<std::string> & /* _return */, const int8_t /* protocol */, const int64_t /* minPartitions */) {
    return;
  }
  void setPartitions(const std::vector<std::string> & /* partitions */) {
    return;
  }
  void setPartitions2(const std::vector<std::string> & /* partitions */, const  ::ignis::rpc::ISource& /* src */) {
    return;
  }
  void newEmptyPartitions(const int64_t /* n */) {
    return;
  }
  void newEmptyPartitions2(const int64_t /* n */, const  ::ignis::rpc::ISource& /* src */) {
    return;
  }
  void driverGather(const std::string& /* group */, const  ::ignis::rpc::ISource& /* src */) {
    return;
  }
  void driverGather0(const std::string& /* group */, const  ::ignis::rpc::ISource& /* src */) {
    return;
  }
  void driverScatter(const std::string& /* group */, const int64_t /* partitions */) {
    return;
  }
  void driverScatter3(const std::string& /* group */, const int64_t /* partitions */, const  ::ignis::rpc::ISource& /* src */) {
    return;
  }
  int32_t enableMultithreading(const std::string& /* group */) {
    int32_t _return = 0;
    return _return;
  }
  void send(const std::string& /* group */, const int64_t /* partition */, const int64_t /* dest */, const int32_t /* thread */) {
    return;
  }
  void recv(const std::string& /* group */, const int64_t /* partition */, const int64_t /* source */, const int32_t /* thread */) {
    return;
  }
};


class ICommModule_openGroup_args {
 public:

  ICommModule_openGroup_args(const ICommModule_openGroup_args&);
  ICommModule_openGroup_args& operator=(const ICommModule_openGroup_args&);
  ICommModule_openGroup_args() {
  }

  virtual ~ICommModule_openGroup_args() noexcept;

  bool operator == (const ICommModule_openGroup_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ICommModule_openGroup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_openGroup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_openGroup_pargs {
 public:


  virtual ~ICommModule_openGroup_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_openGroup_result__isset {
  _ICommModule_openGroup_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_openGroup_result__isset;

class ICommModule_openGroup_result {
 public:

  ICommModule_openGroup_result(const ICommModule_openGroup_result&);
  ICommModule_openGroup_result& operator=(const ICommModule_openGroup_result&);
  ICommModule_openGroup_result() : success() {
  }

  virtual ~ICommModule_openGroup_result() noexcept;
  std::string success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_openGroup_result__isset __isset;

  void __set_success(const std::string& val);

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_openGroup_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_openGroup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_openGroup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_openGroup_presult__isset {
  _ICommModule_openGroup_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_openGroup_presult__isset;

class ICommModule_openGroup_presult {
 public:


  virtual ~ICommModule_openGroup_presult() noexcept;
  std::string* success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_openGroup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class ICommModule_closeGroup_args {
 public:

  ICommModule_closeGroup_args(const ICommModule_closeGroup_args&);
  ICommModule_closeGroup_args& operator=(const ICommModule_closeGroup_args&);
  ICommModule_closeGroup_args() {
  }

  virtual ~ICommModule_closeGroup_args() noexcept;

  bool operator == (const ICommModule_closeGroup_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ICommModule_closeGroup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_closeGroup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_closeGroup_pargs {
 public:


  virtual ~ICommModule_closeGroup_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_closeGroup_result__isset {
  _ICommModule_closeGroup_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_closeGroup_result__isset;

class ICommModule_closeGroup_result {
 public:

  ICommModule_closeGroup_result(const ICommModule_closeGroup_result&);
  ICommModule_closeGroup_result& operator=(const ICommModule_closeGroup_result&);
  ICommModule_closeGroup_result() {
  }

  virtual ~ICommModule_closeGroup_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_closeGroup_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_closeGroup_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_closeGroup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_closeGroup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_closeGroup_presult__isset {
  _ICommModule_closeGroup_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_closeGroup_presult__isset;

class ICommModule_closeGroup_presult {
 public:


  virtual ~ICommModule_closeGroup_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_closeGroup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_joinToGroup_args__isset {
  _ICommModule_joinToGroup_args__isset() : id(false), leader(false) {}
  bool id :1;
  bool leader :1;
} _ICommModule_joinToGroup_args__isset;

class ICommModule_joinToGroup_args {
 public:

  ICommModule_joinToGroup_args(const ICommModule_joinToGroup_args&);
  ICommModule_joinToGroup_args& operator=(const ICommModule_joinToGroup_args&);
  ICommModule_joinToGroup_args() : id(), leader(0) {
  }

  virtual ~ICommModule_joinToGroup_args() noexcept;
  std::string id;
  bool leader;

  _ICommModule_joinToGroup_args__isset __isset;

  void __set_id(const std::string& val);

  void __set_leader(const bool val);

  bool operator == (const ICommModule_joinToGroup_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(leader == rhs.leader))
      return false;
    return true;
  }
  bool operator != (const ICommModule_joinToGroup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_joinToGroup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_joinToGroup_pargs {
 public:


  virtual ~ICommModule_joinToGroup_pargs() noexcept;
  const std::string* id;
  const bool* leader;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_joinToGroup_result__isset {
  _ICommModule_joinToGroup_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_joinToGroup_result__isset;

class ICommModule_joinToGroup_result {
 public:

  ICommModule_joinToGroup_result(const ICommModule_joinToGroup_result&);
  ICommModule_joinToGroup_result& operator=(const ICommModule_joinToGroup_result&);
  ICommModule_joinToGroup_result() {
  }

  virtual ~ICommModule_joinToGroup_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_joinToGroup_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_joinToGroup_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_joinToGroup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_joinToGroup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_joinToGroup_presult__isset {
  _ICommModule_joinToGroup_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_joinToGroup_presult__isset;

class ICommModule_joinToGroup_presult {
 public:


  virtual ~ICommModule_joinToGroup_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_joinToGroup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_joinToGroupName_args__isset {
  _ICommModule_joinToGroupName_args__isset() : id(false), leader(false), name(false) {}
  bool id :1;
  bool leader :1;
  bool name :1;
} _ICommModule_joinToGroupName_args__isset;

class ICommModule_joinToGroupName_args {
 public:

  ICommModule_joinToGroupName_args(const ICommModule_joinToGroupName_args&);
  ICommModule_joinToGroupName_args& operator=(const ICommModule_joinToGroupName_args&);
  ICommModule_joinToGroupName_args() : id(), leader(0), name() {
  }

  virtual ~ICommModule_joinToGroupName_args() noexcept;
  std::string id;
  bool leader;
  std::string name;

  _ICommModule_joinToGroupName_args__isset __isset;

  void __set_id(const std::string& val);

  void __set_leader(const bool val);

  void __set_name(const std::string& val);

  bool operator == (const ICommModule_joinToGroupName_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(leader == rhs.leader))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const ICommModule_joinToGroupName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_joinToGroupName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_joinToGroupName_pargs {
 public:


  virtual ~ICommModule_joinToGroupName_pargs() noexcept;
  const std::string* id;
  const bool* leader;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_joinToGroupName_result__isset {
  _ICommModule_joinToGroupName_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_joinToGroupName_result__isset;

class ICommModule_joinToGroupName_result {
 public:

  ICommModule_joinToGroupName_result(const ICommModule_joinToGroupName_result&);
  ICommModule_joinToGroupName_result& operator=(const ICommModule_joinToGroupName_result&);
  ICommModule_joinToGroupName_result() {
  }

  virtual ~ICommModule_joinToGroupName_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_joinToGroupName_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_joinToGroupName_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_joinToGroupName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_joinToGroupName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_joinToGroupName_presult__isset {
  _ICommModule_joinToGroupName_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_joinToGroupName_presult__isset;

class ICommModule_joinToGroupName_presult {
 public:


  virtual ~ICommModule_joinToGroupName_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_joinToGroupName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_hasGroup_args__isset {
  _ICommModule_hasGroup_args__isset() : name(false) {}
  bool name :1;
} _ICommModule_hasGroup_args__isset;

class ICommModule_hasGroup_args {
 public:

  ICommModule_hasGroup_args(const ICommModule_hasGroup_args&);
  ICommModule_hasGroup_args& operator=(const ICommModule_hasGroup_args&);
  ICommModule_hasGroup_args() : name() {
  }

  virtual ~ICommModule_hasGroup_args() noexcept;
  std::string name;

  _ICommModule_hasGroup_args__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const ICommModule_hasGroup_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const ICommModule_hasGroup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_hasGroup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_hasGroup_pargs {
 public:


  virtual ~ICommModule_hasGroup_pargs() noexcept;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_hasGroup_result__isset {
  _ICommModule_hasGroup_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_hasGroup_result__isset;

class ICommModule_hasGroup_result {
 public:

  ICommModule_hasGroup_result(const ICommModule_hasGroup_result&);
  ICommModule_hasGroup_result& operator=(const ICommModule_hasGroup_result&);
  ICommModule_hasGroup_result() : success(0) {
  }

  virtual ~ICommModule_hasGroup_result() noexcept;
  bool success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_hasGroup_result__isset __isset;

  void __set_success(const bool val);

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_hasGroup_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_hasGroup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_hasGroup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_hasGroup_presult__isset {
  _ICommModule_hasGroup_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_hasGroup_presult__isset;

class ICommModule_hasGroup_presult {
 public:


  virtual ~ICommModule_hasGroup_presult() noexcept;
  bool* success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_hasGroup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_destroyGroup_args__isset {
  _ICommModule_destroyGroup_args__isset() : name(false) {}
  bool name :1;
} _ICommModule_destroyGroup_args__isset;

class ICommModule_destroyGroup_args {
 public:

  ICommModule_destroyGroup_args(const ICommModule_destroyGroup_args&);
  ICommModule_destroyGroup_args& operator=(const ICommModule_destroyGroup_args&);
  ICommModule_destroyGroup_args() : name() {
  }

  virtual ~ICommModule_destroyGroup_args() noexcept;
  std::string name;

  _ICommModule_destroyGroup_args__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const ICommModule_destroyGroup_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const ICommModule_destroyGroup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_destroyGroup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_destroyGroup_pargs {
 public:


  virtual ~ICommModule_destroyGroup_pargs() noexcept;
  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_destroyGroup_result__isset {
  _ICommModule_destroyGroup_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_destroyGroup_result__isset;

class ICommModule_destroyGroup_result {
 public:

  ICommModule_destroyGroup_result(const ICommModule_destroyGroup_result&);
  ICommModule_destroyGroup_result& operator=(const ICommModule_destroyGroup_result&);
  ICommModule_destroyGroup_result() {
  }

  virtual ~ICommModule_destroyGroup_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_destroyGroup_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_destroyGroup_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_destroyGroup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_destroyGroup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_destroyGroup_presult__isset {
  _ICommModule_destroyGroup_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_destroyGroup_presult__isset;

class ICommModule_destroyGroup_presult {
 public:


  virtual ~ICommModule_destroyGroup_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_destroyGroup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class ICommModule_destroyGroups_args {
 public:

  ICommModule_destroyGroups_args(const ICommModule_destroyGroups_args&);
  ICommModule_destroyGroups_args& operator=(const ICommModule_destroyGroups_args&);
  ICommModule_destroyGroups_args() {
  }

  virtual ~ICommModule_destroyGroups_args() noexcept;

  bool operator == (const ICommModule_destroyGroups_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ICommModule_destroyGroups_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_destroyGroups_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_destroyGroups_pargs {
 public:


  virtual ~ICommModule_destroyGroups_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_destroyGroups_result__isset {
  _ICommModule_destroyGroups_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_destroyGroups_result__isset;

class ICommModule_destroyGroups_result {
 public:

  ICommModule_destroyGroups_result(const ICommModule_destroyGroups_result&);
  ICommModule_destroyGroups_result& operator=(const ICommModule_destroyGroups_result&);
  ICommModule_destroyGroups_result() {
  }

  virtual ~ICommModule_destroyGroups_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_destroyGroups_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_destroyGroups_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_destroyGroups_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_destroyGroups_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_destroyGroups_presult__isset {
  _ICommModule_destroyGroups_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_destroyGroups_presult__isset;

class ICommModule_destroyGroups_presult {
 public:


  virtual ~ICommModule_destroyGroups_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_destroyGroups_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class ICommModule_getProtocol_args {
 public:

  ICommModule_getProtocol_args(const ICommModule_getProtocol_args&);
  ICommModule_getProtocol_args& operator=(const ICommModule_getProtocol_args&);
  ICommModule_getProtocol_args() {
  }

  virtual ~ICommModule_getProtocol_args() noexcept;

  bool operator == (const ICommModule_getProtocol_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const ICommModule_getProtocol_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_getProtocol_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_getProtocol_pargs {
 public:


  virtual ~ICommModule_getProtocol_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_getProtocol_result__isset {
  _ICommModule_getProtocol_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_getProtocol_result__isset;

class ICommModule_getProtocol_result {
 public:

  ICommModule_getProtocol_result(const ICommModule_getProtocol_result&);
  ICommModule_getProtocol_result& operator=(const ICommModule_getProtocol_result&);
  ICommModule_getProtocol_result() : success(0) {
  }

  virtual ~ICommModule_getProtocol_result() noexcept;
  int8_t success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_getProtocol_result__isset __isset;

  void __set_success(const int8_t val);

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_getProtocol_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_getProtocol_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_getProtocol_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_getProtocol_presult__isset {
  _ICommModule_getProtocol_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_getProtocol_presult__isset;

class ICommModule_getProtocol_presult {
 public:


  virtual ~ICommModule_getProtocol_presult() noexcept;
  int8_t* success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_getProtocol_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_getPartitions_args__isset {
  _ICommModule_getPartitions_args__isset() : protocol(false) {}
  bool protocol :1;
} _ICommModule_getPartitions_args__isset;

class ICommModule_getPartitions_args {
 public:

  ICommModule_getPartitions_args(const ICommModule_getPartitions_args&);
  ICommModule_getPartitions_args& operator=(const ICommModule_getPartitions_args&);
  ICommModule_getPartitions_args() : protocol(0) {
  }

  virtual ~ICommModule_getPartitions_args() noexcept;
  int8_t protocol;

  _ICommModule_getPartitions_args__isset __isset;

  void __set_protocol(const int8_t val);

  bool operator == (const ICommModule_getPartitions_args & rhs) const
  {
    if (!(protocol == rhs.protocol))
      return false;
    return true;
  }
  bool operator != (const ICommModule_getPartitions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_getPartitions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_getPartitions_pargs {
 public:


  virtual ~ICommModule_getPartitions_pargs() noexcept;
  const int8_t* protocol;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_getPartitions_result__isset {
  _ICommModule_getPartitions_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_getPartitions_result__isset;

class ICommModule_getPartitions_result {
 public:

  ICommModule_getPartitions_result(const ICommModule_getPartitions_result&);
  ICommModule_getPartitions_result& operator=(const ICommModule_getPartitions_result&);
  ICommModule_getPartitions_result() {
  }

  virtual ~ICommModule_getPartitions_result() noexcept;
  std::vector<std::string>  success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_getPartitions_result__isset __isset;

  void __set_success(const std::vector<std::string> & val);

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_getPartitions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_getPartitions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_getPartitions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_getPartitions_presult__isset {
  _ICommModule_getPartitions_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_getPartitions_presult__isset;

class ICommModule_getPartitions_presult {
 public:


  virtual ~ICommModule_getPartitions_presult() noexcept;
  std::vector<std::string> * success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_getPartitions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_getPartitions2_args__isset {
  _ICommModule_getPartitions2_args__isset() : protocol(false), minPartitions(false) {}
  bool protocol :1;
  bool minPartitions :1;
} _ICommModule_getPartitions2_args__isset;

class ICommModule_getPartitions2_args {
 public:

  ICommModule_getPartitions2_args(const ICommModule_getPartitions2_args&);
  ICommModule_getPartitions2_args& operator=(const ICommModule_getPartitions2_args&);
  ICommModule_getPartitions2_args() : protocol(0), minPartitions(0) {
  }

  virtual ~ICommModule_getPartitions2_args() noexcept;
  int8_t protocol;
  int64_t minPartitions;

  _ICommModule_getPartitions2_args__isset __isset;

  void __set_protocol(const int8_t val);

  void __set_minPartitions(const int64_t val);

  bool operator == (const ICommModule_getPartitions2_args & rhs) const
  {
    if (!(protocol == rhs.protocol))
      return false;
    if (!(minPartitions == rhs.minPartitions))
      return false;
    return true;
  }
  bool operator != (const ICommModule_getPartitions2_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_getPartitions2_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_getPartitions2_pargs {
 public:


  virtual ~ICommModule_getPartitions2_pargs() noexcept;
  const int8_t* protocol;
  const int64_t* minPartitions;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_getPartitions2_result__isset {
  _ICommModule_getPartitions2_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_getPartitions2_result__isset;

class ICommModule_getPartitions2_result {
 public:

  ICommModule_getPartitions2_result(const ICommModule_getPartitions2_result&);
  ICommModule_getPartitions2_result& operator=(const ICommModule_getPartitions2_result&);
  ICommModule_getPartitions2_result() {
  }

  virtual ~ICommModule_getPartitions2_result() noexcept;
  std::vector<std::string>  success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_getPartitions2_result__isset __isset;

  void __set_success(const std::vector<std::string> & val);

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_getPartitions2_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_getPartitions2_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_getPartitions2_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_getPartitions2_presult__isset {
  _ICommModule_getPartitions2_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_getPartitions2_presult__isset;

class ICommModule_getPartitions2_presult {
 public:


  virtual ~ICommModule_getPartitions2_presult() noexcept;
  std::vector<std::string> * success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_getPartitions2_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_setPartitions_args__isset {
  _ICommModule_setPartitions_args__isset() : partitions(false) {}
  bool partitions :1;
} _ICommModule_setPartitions_args__isset;

class ICommModule_setPartitions_args {
 public:

  ICommModule_setPartitions_args(const ICommModule_setPartitions_args&);
  ICommModule_setPartitions_args& operator=(const ICommModule_setPartitions_args&);
  ICommModule_setPartitions_args() {
  }

  virtual ~ICommModule_setPartitions_args() noexcept;
  std::vector<std::string>  partitions;

  _ICommModule_setPartitions_args__isset __isset;

  void __set_partitions(const std::vector<std::string> & val);

  bool operator == (const ICommModule_setPartitions_args & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const ICommModule_setPartitions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_setPartitions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_setPartitions_pargs {
 public:


  virtual ~ICommModule_setPartitions_pargs() noexcept;
  const std::vector<std::string> * partitions;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_setPartitions_result__isset {
  _ICommModule_setPartitions_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_setPartitions_result__isset;

class ICommModule_setPartitions_result {
 public:

  ICommModule_setPartitions_result(const ICommModule_setPartitions_result&);
  ICommModule_setPartitions_result& operator=(const ICommModule_setPartitions_result&);
  ICommModule_setPartitions_result() {
  }

  virtual ~ICommModule_setPartitions_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_setPartitions_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_setPartitions_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_setPartitions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_setPartitions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_setPartitions_presult__isset {
  _ICommModule_setPartitions_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_setPartitions_presult__isset;

class ICommModule_setPartitions_presult {
 public:


  virtual ~ICommModule_setPartitions_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_setPartitions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_setPartitions2_args__isset {
  _ICommModule_setPartitions2_args__isset() : partitions(false), src(false) {}
  bool partitions :1;
  bool src :1;
} _ICommModule_setPartitions2_args__isset;

class ICommModule_setPartitions2_args {
 public:

  ICommModule_setPartitions2_args(const ICommModule_setPartitions2_args&);
  ICommModule_setPartitions2_args& operator=(const ICommModule_setPartitions2_args&);
  ICommModule_setPartitions2_args() {
  }

  virtual ~ICommModule_setPartitions2_args() noexcept;
  std::vector<std::string>  partitions;
   ::ignis::rpc::ISource src;

  _ICommModule_setPartitions2_args__isset __isset;

  void __set_partitions(const std::vector<std::string> & val);

  void __set_src(const  ::ignis::rpc::ISource& val);

  bool operator == (const ICommModule_setPartitions2_args & rhs) const
  {
    if (!(partitions == rhs.partitions))
      return false;
    if (!(src == rhs.src))
      return false;
    return true;
  }
  bool operator != (const ICommModule_setPartitions2_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_setPartitions2_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_setPartitions2_pargs {
 public:


  virtual ~ICommModule_setPartitions2_pargs() noexcept;
  const std::vector<std::string> * partitions;
  const  ::ignis::rpc::ISource* src;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_setPartitions2_result__isset {
  _ICommModule_setPartitions2_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_setPartitions2_result__isset;

class ICommModule_setPartitions2_result {
 public:

  ICommModule_setPartitions2_result(const ICommModule_setPartitions2_result&);
  ICommModule_setPartitions2_result& operator=(const ICommModule_setPartitions2_result&);
  ICommModule_setPartitions2_result() {
  }

  virtual ~ICommModule_setPartitions2_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_setPartitions2_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_setPartitions2_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_setPartitions2_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_setPartitions2_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_setPartitions2_presult__isset {
  _ICommModule_setPartitions2_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_setPartitions2_presult__isset;

class ICommModule_setPartitions2_presult {
 public:


  virtual ~ICommModule_setPartitions2_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_setPartitions2_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_newEmptyPartitions_args__isset {
  _ICommModule_newEmptyPartitions_args__isset() : n(false) {}
  bool n :1;
} _ICommModule_newEmptyPartitions_args__isset;

class ICommModule_newEmptyPartitions_args {
 public:

  ICommModule_newEmptyPartitions_args(const ICommModule_newEmptyPartitions_args&);
  ICommModule_newEmptyPartitions_args& operator=(const ICommModule_newEmptyPartitions_args&);
  ICommModule_newEmptyPartitions_args() : n(0) {
  }

  virtual ~ICommModule_newEmptyPartitions_args() noexcept;
  int64_t n;

  _ICommModule_newEmptyPartitions_args__isset __isset;

  void __set_n(const int64_t val);

  bool operator == (const ICommModule_newEmptyPartitions_args & rhs) const
  {
    if (!(n == rhs.n))
      return false;
    return true;
  }
  bool operator != (const ICommModule_newEmptyPartitions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_newEmptyPartitions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_newEmptyPartitions_pargs {
 public:


  virtual ~ICommModule_newEmptyPartitions_pargs() noexcept;
  const int64_t* n;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_newEmptyPartitions_result__isset {
  _ICommModule_newEmptyPartitions_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_newEmptyPartitions_result__isset;

class ICommModule_newEmptyPartitions_result {
 public:

  ICommModule_newEmptyPartitions_result(const ICommModule_newEmptyPartitions_result&);
  ICommModule_newEmptyPartitions_result& operator=(const ICommModule_newEmptyPartitions_result&);
  ICommModule_newEmptyPartitions_result() {
  }

  virtual ~ICommModule_newEmptyPartitions_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_newEmptyPartitions_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_newEmptyPartitions_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_newEmptyPartitions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_newEmptyPartitions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_newEmptyPartitions_presult__isset {
  _ICommModule_newEmptyPartitions_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_newEmptyPartitions_presult__isset;

class ICommModule_newEmptyPartitions_presult {
 public:


  virtual ~ICommModule_newEmptyPartitions_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_newEmptyPartitions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_newEmptyPartitions2_args__isset {
  _ICommModule_newEmptyPartitions2_args__isset() : n(false), src(false) {}
  bool n :1;
  bool src :1;
} _ICommModule_newEmptyPartitions2_args__isset;

class ICommModule_newEmptyPartitions2_args {
 public:

  ICommModule_newEmptyPartitions2_args(const ICommModule_newEmptyPartitions2_args&);
  ICommModule_newEmptyPartitions2_args& operator=(const ICommModule_newEmptyPartitions2_args&);
  ICommModule_newEmptyPartitions2_args() : n(0) {
  }

  virtual ~ICommModule_newEmptyPartitions2_args() noexcept;
  int64_t n;
   ::ignis::rpc::ISource src;

  _ICommModule_newEmptyPartitions2_args__isset __isset;

  void __set_n(const int64_t val);

  void __set_src(const  ::ignis::rpc::ISource& val);

  bool operator == (const ICommModule_newEmptyPartitions2_args & rhs) const
  {
    if (!(n == rhs.n))
      return false;
    if (!(src == rhs.src))
      return false;
    return true;
  }
  bool operator != (const ICommModule_newEmptyPartitions2_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_newEmptyPartitions2_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_newEmptyPartitions2_pargs {
 public:


  virtual ~ICommModule_newEmptyPartitions2_pargs() noexcept;
  const int64_t* n;
  const  ::ignis::rpc::ISource* src;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_newEmptyPartitions2_result__isset {
  _ICommModule_newEmptyPartitions2_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_newEmptyPartitions2_result__isset;

class ICommModule_newEmptyPartitions2_result {
 public:

  ICommModule_newEmptyPartitions2_result(const ICommModule_newEmptyPartitions2_result&);
  ICommModule_newEmptyPartitions2_result& operator=(const ICommModule_newEmptyPartitions2_result&);
  ICommModule_newEmptyPartitions2_result() {
  }

  virtual ~ICommModule_newEmptyPartitions2_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_newEmptyPartitions2_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_newEmptyPartitions2_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_newEmptyPartitions2_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_newEmptyPartitions2_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_newEmptyPartitions2_presult__isset {
  _ICommModule_newEmptyPartitions2_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_newEmptyPartitions2_presult__isset;

class ICommModule_newEmptyPartitions2_presult {
 public:


  virtual ~ICommModule_newEmptyPartitions2_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_newEmptyPartitions2_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_driverGather_args__isset {
  _ICommModule_driverGather_args__isset() : group(false), src(false) {}
  bool group :1;
  bool src :1;
} _ICommModule_driverGather_args__isset;

class ICommModule_driverGather_args {
 public:

  ICommModule_driverGather_args(const ICommModule_driverGather_args&);
  ICommModule_driverGather_args& operator=(const ICommModule_driverGather_args&);
  ICommModule_driverGather_args() : group() {
  }

  virtual ~ICommModule_driverGather_args() noexcept;
  std::string group;
   ::ignis::rpc::ISource src;

  _ICommModule_driverGather_args__isset __isset;

  void __set_group(const std::string& val);

  void __set_src(const  ::ignis::rpc::ISource& val);

  bool operator == (const ICommModule_driverGather_args & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(src == rhs.src))
      return false;
    return true;
  }
  bool operator != (const ICommModule_driverGather_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_driverGather_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_driverGather_pargs {
 public:


  virtual ~ICommModule_driverGather_pargs() noexcept;
  const std::string* group;
  const  ::ignis::rpc::ISource* src;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_driverGather_result__isset {
  _ICommModule_driverGather_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_driverGather_result__isset;

class ICommModule_driverGather_result {
 public:

  ICommModule_driverGather_result(const ICommModule_driverGather_result&);
  ICommModule_driverGather_result& operator=(const ICommModule_driverGather_result&);
  ICommModule_driverGather_result() {
  }

  virtual ~ICommModule_driverGather_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_driverGather_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_driverGather_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_driverGather_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_driverGather_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_driverGather_presult__isset {
  _ICommModule_driverGather_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_driverGather_presult__isset;

class ICommModule_driverGather_presult {
 public:


  virtual ~ICommModule_driverGather_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_driverGather_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_driverGather0_args__isset {
  _ICommModule_driverGather0_args__isset() : group(false), src(false) {}
  bool group :1;
  bool src :1;
} _ICommModule_driverGather0_args__isset;

class ICommModule_driverGather0_args {
 public:

  ICommModule_driverGather0_args(const ICommModule_driverGather0_args&);
  ICommModule_driverGather0_args& operator=(const ICommModule_driverGather0_args&);
  ICommModule_driverGather0_args() : group() {
  }

  virtual ~ICommModule_driverGather0_args() noexcept;
  std::string group;
   ::ignis::rpc::ISource src;

  _ICommModule_driverGather0_args__isset __isset;

  void __set_group(const std::string& val);

  void __set_src(const  ::ignis::rpc::ISource& val);

  bool operator == (const ICommModule_driverGather0_args & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(src == rhs.src))
      return false;
    return true;
  }
  bool operator != (const ICommModule_driverGather0_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_driverGather0_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_driverGather0_pargs {
 public:


  virtual ~ICommModule_driverGather0_pargs() noexcept;
  const std::string* group;
  const  ::ignis::rpc::ISource* src;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_driverGather0_result__isset {
  _ICommModule_driverGather0_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_driverGather0_result__isset;

class ICommModule_driverGather0_result {
 public:

  ICommModule_driverGather0_result(const ICommModule_driverGather0_result&);
  ICommModule_driverGather0_result& operator=(const ICommModule_driverGather0_result&);
  ICommModule_driverGather0_result() {
  }

  virtual ~ICommModule_driverGather0_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_driverGather0_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_driverGather0_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_driverGather0_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_driverGather0_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_driverGather0_presult__isset {
  _ICommModule_driverGather0_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_driverGather0_presult__isset;

class ICommModule_driverGather0_presult {
 public:


  virtual ~ICommModule_driverGather0_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_driverGather0_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_driverScatter_args__isset {
  _ICommModule_driverScatter_args__isset() : group(false), partitions(false) {}
  bool group :1;
  bool partitions :1;
} _ICommModule_driverScatter_args__isset;

class ICommModule_driverScatter_args {
 public:

  ICommModule_driverScatter_args(const ICommModule_driverScatter_args&);
  ICommModule_driverScatter_args& operator=(const ICommModule_driverScatter_args&);
  ICommModule_driverScatter_args() : group(), partitions(0) {
  }

  virtual ~ICommModule_driverScatter_args() noexcept;
  std::string group;
  int64_t partitions;

  _ICommModule_driverScatter_args__isset __isset;

  void __set_group(const std::string& val);

  void __set_partitions(const int64_t val);

  bool operator == (const ICommModule_driverScatter_args & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const ICommModule_driverScatter_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_driverScatter_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_driverScatter_pargs {
 public:


  virtual ~ICommModule_driverScatter_pargs() noexcept;
  const std::string* group;
  const int64_t* partitions;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_driverScatter_result__isset {
  _ICommModule_driverScatter_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_driverScatter_result__isset;

class ICommModule_driverScatter_result {
 public:

  ICommModule_driverScatter_result(const ICommModule_driverScatter_result&);
  ICommModule_driverScatter_result& operator=(const ICommModule_driverScatter_result&);
  ICommModule_driverScatter_result() {
  }

  virtual ~ICommModule_driverScatter_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_driverScatter_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_driverScatter_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_driverScatter_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_driverScatter_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_driverScatter_presult__isset {
  _ICommModule_driverScatter_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_driverScatter_presult__isset;

class ICommModule_driverScatter_presult {
 public:


  virtual ~ICommModule_driverScatter_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_driverScatter_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_driverScatter3_args__isset {
  _ICommModule_driverScatter3_args__isset() : group(false), partitions(false), src(false) {}
  bool group :1;
  bool partitions :1;
  bool src :1;
} _ICommModule_driverScatter3_args__isset;

class ICommModule_driverScatter3_args {
 public:

  ICommModule_driverScatter3_args(const ICommModule_driverScatter3_args&);
  ICommModule_driverScatter3_args& operator=(const ICommModule_driverScatter3_args&);
  ICommModule_driverScatter3_args() : group(), partitions(0) {
  }

  virtual ~ICommModule_driverScatter3_args() noexcept;
  std::string group;
  int64_t partitions;
   ::ignis::rpc::ISource src;

  _ICommModule_driverScatter3_args__isset __isset;

  void __set_group(const std::string& val);

  void __set_partitions(const int64_t val);

  void __set_src(const  ::ignis::rpc::ISource& val);

  bool operator == (const ICommModule_driverScatter3_args & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    if (!(src == rhs.src))
      return false;
    return true;
  }
  bool operator != (const ICommModule_driverScatter3_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_driverScatter3_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_driverScatter3_pargs {
 public:


  virtual ~ICommModule_driverScatter3_pargs() noexcept;
  const std::string* group;
  const int64_t* partitions;
  const  ::ignis::rpc::ISource* src;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_driverScatter3_result__isset {
  _ICommModule_driverScatter3_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_driverScatter3_result__isset;

class ICommModule_driverScatter3_result {
 public:

  ICommModule_driverScatter3_result(const ICommModule_driverScatter3_result&);
  ICommModule_driverScatter3_result& operator=(const ICommModule_driverScatter3_result&);
  ICommModule_driverScatter3_result() {
  }

  virtual ~ICommModule_driverScatter3_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_driverScatter3_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_driverScatter3_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_driverScatter3_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_driverScatter3_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_driverScatter3_presult__isset {
  _ICommModule_driverScatter3_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_driverScatter3_presult__isset;

class ICommModule_driverScatter3_presult {
 public:


  virtual ~ICommModule_driverScatter3_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_driverScatter3_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_enableMultithreading_args__isset {
  _ICommModule_enableMultithreading_args__isset() : group(false) {}
  bool group :1;
} _ICommModule_enableMultithreading_args__isset;

class ICommModule_enableMultithreading_args {
 public:

  ICommModule_enableMultithreading_args(const ICommModule_enableMultithreading_args&);
  ICommModule_enableMultithreading_args& operator=(const ICommModule_enableMultithreading_args&);
  ICommModule_enableMultithreading_args() : group() {
  }

  virtual ~ICommModule_enableMultithreading_args() noexcept;
  std::string group;

  _ICommModule_enableMultithreading_args__isset __isset;

  void __set_group(const std::string& val);

  bool operator == (const ICommModule_enableMultithreading_args & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    return true;
  }
  bool operator != (const ICommModule_enableMultithreading_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_enableMultithreading_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_enableMultithreading_pargs {
 public:


  virtual ~ICommModule_enableMultithreading_pargs() noexcept;
  const std::string* group;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_enableMultithreading_result__isset {
  _ICommModule_enableMultithreading_result__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_enableMultithreading_result__isset;

class ICommModule_enableMultithreading_result {
 public:

  ICommModule_enableMultithreading_result(const ICommModule_enableMultithreading_result&);
  ICommModule_enableMultithreading_result& operator=(const ICommModule_enableMultithreading_result&);
  ICommModule_enableMultithreading_result() : success(0) {
  }

  virtual ~ICommModule_enableMultithreading_result() noexcept;
  int32_t success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_enableMultithreading_result__isset __isset;

  void __set_success(const int32_t val);

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_enableMultithreading_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_enableMultithreading_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_enableMultithreading_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_enableMultithreading_presult__isset {
  _ICommModule_enableMultithreading_presult__isset() : success(false), ex(false) {}
  bool success :1;
  bool ex :1;
} _ICommModule_enableMultithreading_presult__isset;

class ICommModule_enableMultithreading_presult {
 public:


  virtual ~ICommModule_enableMultithreading_presult() noexcept;
  int32_t* success;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_enableMultithreading_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_send_args__isset {
  _ICommModule_send_args__isset() : group(false), partition(false), dest(false), thread(false) {}
  bool group :1;
  bool partition :1;
  bool dest :1;
  bool thread :1;
} _ICommModule_send_args__isset;

class ICommModule_send_args {
 public:

  ICommModule_send_args(const ICommModule_send_args&);
  ICommModule_send_args& operator=(const ICommModule_send_args&);
  ICommModule_send_args() : group(), partition(0), dest(0), thread(0) {
  }

  virtual ~ICommModule_send_args() noexcept;
  std::string group;
  int64_t partition;
  int64_t dest;
  int32_t thread;

  _ICommModule_send_args__isset __isset;

  void __set_group(const std::string& val);

  void __set_partition(const int64_t val);

  void __set_dest(const int64_t val);

  void __set_thread(const int32_t val);

  bool operator == (const ICommModule_send_args & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(partition == rhs.partition))
      return false;
    if (!(dest == rhs.dest))
      return false;
    if (!(thread == rhs.thread))
      return false;
    return true;
  }
  bool operator != (const ICommModule_send_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_send_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_send_pargs {
 public:


  virtual ~ICommModule_send_pargs() noexcept;
  const std::string* group;
  const int64_t* partition;
  const int64_t* dest;
  const int32_t* thread;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_send_result__isset {
  _ICommModule_send_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_send_result__isset;

class ICommModule_send_result {
 public:

  ICommModule_send_result(const ICommModule_send_result&);
  ICommModule_send_result& operator=(const ICommModule_send_result&);
  ICommModule_send_result() {
  }

  virtual ~ICommModule_send_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_send_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_send_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_send_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_send_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_send_presult__isset {
  _ICommModule_send_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_send_presult__isset;

class ICommModule_send_presult {
 public:


  virtual ~ICommModule_send_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_send_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _ICommModule_recv_args__isset {
  _ICommModule_recv_args__isset() : group(false), partition(false), source(false), thread(false) {}
  bool group :1;
  bool partition :1;
  bool source :1;
  bool thread :1;
} _ICommModule_recv_args__isset;

class ICommModule_recv_args {
 public:

  ICommModule_recv_args(const ICommModule_recv_args&);
  ICommModule_recv_args& operator=(const ICommModule_recv_args&);
  ICommModule_recv_args() : group(), partition(0), source(0), thread(0) {
  }

  virtual ~ICommModule_recv_args() noexcept;
  std::string group;
  int64_t partition;
  int64_t source;
  int32_t thread;

  _ICommModule_recv_args__isset __isset;

  void __set_group(const std::string& val);

  void __set_partition(const int64_t val);

  void __set_source(const int64_t val);

  void __set_thread(const int32_t val);

  bool operator == (const ICommModule_recv_args & rhs) const
  {
    if (!(group == rhs.group))
      return false;
    if (!(partition == rhs.partition))
      return false;
    if (!(source == rhs.source))
      return false;
    if (!(thread == rhs.thread))
      return false;
    return true;
  }
  bool operator != (const ICommModule_recv_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_recv_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ICommModule_recv_pargs {
 public:


  virtual ~ICommModule_recv_pargs() noexcept;
  const std::string* group;
  const int64_t* partition;
  const int64_t* source;
  const int32_t* thread;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_recv_result__isset {
  _ICommModule_recv_result__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_recv_result__isset;

class ICommModule_recv_result {
 public:

  ICommModule_recv_result(const ICommModule_recv_result&);
  ICommModule_recv_result& operator=(const ICommModule_recv_result&);
  ICommModule_recv_result() {
  }

  virtual ~ICommModule_recv_result() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_recv_result__isset __isset;

  void __set_ex(const  ::ignis::rpc::IExecutorException& val);

  bool operator == (const ICommModule_recv_result & rhs) const
  {
    if (!(ex == rhs.ex))
      return false;
    return true;
  }
  bool operator != (const ICommModule_recv_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ICommModule_recv_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _ICommModule_recv_presult__isset {
  _ICommModule_recv_presult__isset() : ex(false) {}
  bool ex :1;
} _ICommModule_recv_presult__isset;

class ICommModule_recv_presult {
 public:


  virtual ~ICommModule_recv_presult() noexcept;
   ::ignis::rpc::IExecutorException ex;

  _ICommModule_recv_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class ICommModuleClient : virtual public ICommModuleIf {
 public:
  ICommModuleClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  ICommModuleClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void openGroup(std::string& _return);
  void send_openGroup();
  void recv_openGroup(std::string& _return);
  void closeGroup();
  void send_closeGroup();
  void recv_closeGroup();
  void joinToGroup(const std::string& id, const bool leader);
  void send_joinToGroup(const std::string& id, const bool leader);
  void recv_joinToGroup();
  void joinToGroupName(const std::string& id, const bool leader, const std::string& name);
  void send_joinToGroupName(const std::string& id, const bool leader, const std::string& name);
  void recv_joinToGroupName();
  bool hasGroup(const std::string& name);
  void send_hasGroup(const std::string& name);
  bool recv_hasGroup();
  void destroyGroup(const std::string& name);
  void send_destroyGroup(const std::string& name);
  void recv_destroyGroup();
  void destroyGroups();
  void send_destroyGroups();
  void recv_destroyGroups();
  int8_t getProtocol();
  void send_getProtocol();
  int8_t recv_getProtocol();
  void getPartitions(std::vector<std::string> & _return, const int8_t protocol);
  void send_getPartitions(const int8_t protocol);
  void recv_getPartitions(std::vector<std::string> & _return);
  void getPartitions2(std::vector<std::string> & _return, const int8_t protocol, const int64_t minPartitions);
  void send_getPartitions2(const int8_t protocol, const int64_t minPartitions);
  void recv_getPartitions2(std::vector<std::string> & _return);
  void setPartitions(const std::vector<std::string> & partitions);
  void send_setPartitions(const std::vector<std::string> & partitions);
  void recv_setPartitions();
  void setPartitions2(const std::vector<std::string> & partitions, const  ::ignis::rpc::ISource& src);
  void send_setPartitions2(const std::vector<std::string> & partitions, const  ::ignis::rpc::ISource& src);
  void recv_setPartitions2();
  void newEmptyPartitions(const int64_t n);
  void send_newEmptyPartitions(const int64_t n);
  void recv_newEmptyPartitions();
  void newEmptyPartitions2(const int64_t n, const  ::ignis::rpc::ISource& src);
  void send_newEmptyPartitions2(const int64_t n, const  ::ignis::rpc::ISource& src);
  void recv_newEmptyPartitions2();
  void driverGather(const std::string& group, const  ::ignis::rpc::ISource& src);
  void send_driverGather(const std::string& group, const  ::ignis::rpc::ISource& src);
  void recv_driverGather();
  void driverGather0(const std::string& group, const  ::ignis::rpc::ISource& src);
  void send_driverGather0(const std::string& group, const  ::ignis::rpc::ISource& src);
  void recv_driverGather0();
  void driverScatter(const std::string& group, const int64_t partitions);
  void send_driverScatter(const std::string& group, const int64_t partitions);
  void recv_driverScatter();
  void driverScatter3(const std::string& group, const int64_t partitions, const  ::ignis::rpc::ISource& src);
  void send_driverScatter3(const std::string& group, const int64_t partitions, const  ::ignis::rpc::ISource& src);
  void recv_driverScatter3();
  int32_t enableMultithreading(const std::string& group);
  void send_enableMultithreading(const std::string& group);
  int32_t recv_enableMultithreading();
  void send(const std::string& group, const int64_t partition, const int64_t dest, const int32_t thread);
  void send_send(const std::string& group, const int64_t partition, const int64_t dest, const int32_t thread);
  void recv_send();
  void recv(const std::string& group, const int64_t partition, const int64_t source, const int32_t thread);
  void send_recv(const std::string& group, const int64_t partition, const int64_t source, const int32_t thread);
  void recv_recv();
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class ICommModuleProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::std::shared_ptr<ICommModuleIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (ICommModuleProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_openGroup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeGroup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_joinToGroup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_joinToGroupName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_hasGroup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_destroyGroup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_destroyGroups(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getProtocol(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPartitions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getPartitions2(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setPartitions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setPartitions2(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newEmptyPartitions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newEmptyPartitions2(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_driverGather(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_driverGather0(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_driverScatter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_driverScatter3(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_enableMultithreading(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_send(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_recv(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  ICommModuleProcessor(::std::shared_ptr<ICommModuleIf> iface) :
    iface_(iface) {
    processMap_["openGroup"] = &ICommModuleProcessor::process_openGroup;
    processMap_["closeGroup"] = &ICommModuleProcessor::process_closeGroup;
    processMap_["joinToGroup"] = &ICommModuleProcessor::process_joinToGroup;
    processMap_["joinToGroupName"] = &ICommModuleProcessor::process_joinToGroupName;
    processMap_["hasGroup"] = &ICommModuleProcessor::process_hasGroup;
    processMap_["destroyGroup"] = &ICommModuleProcessor::process_destroyGroup;
    processMap_["destroyGroups"] = &ICommModuleProcessor::process_destroyGroups;
    processMap_["getProtocol"] = &ICommModuleProcessor::process_getProtocol;
    processMap_["getPartitions"] = &ICommModuleProcessor::process_getPartitions;
    processMap_["getPartitions2"] = &ICommModuleProcessor::process_getPartitions2;
    processMap_["setPartitions"] = &ICommModuleProcessor::process_setPartitions;
    processMap_["setPartitions2"] = &ICommModuleProcessor::process_setPartitions2;
    processMap_["newEmptyPartitions"] = &ICommModuleProcessor::process_newEmptyPartitions;
    processMap_["newEmptyPartitions2"] = &ICommModuleProcessor::process_newEmptyPartitions2;
    processMap_["driverGather"] = &ICommModuleProcessor::process_driverGather;
    processMap_["driverGather0"] = &ICommModuleProcessor::process_driverGather0;
    processMap_["driverScatter"] = &ICommModuleProcessor::process_driverScatter;
    processMap_["driverScatter3"] = &ICommModuleProcessor::process_driverScatter3;
    processMap_["enableMultithreading"] = &ICommModuleProcessor::process_enableMultithreading;
    processMap_["send"] = &ICommModuleProcessor::process_send;
    processMap_["recv"] = &ICommModuleProcessor::process_recv;
  }

  virtual ~ICommModuleProcessor() {}
};

class ICommModuleProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  ICommModuleProcessorFactory(const ::std::shared_ptr< ICommModuleIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::std::shared_ptr< ICommModuleIfFactory > handlerFactory_;
};

class ICommModuleMultiface : virtual public ICommModuleIf {
 public:
  ICommModuleMultiface(std::vector<std::shared_ptr<ICommModuleIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~ICommModuleMultiface() {}
 protected:
  std::vector<std::shared_ptr<ICommModuleIf> > ifaces_;
  ICommModuleMultiface() {}
  void add(::std::shared_ptr<ICommModuleIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void openGroup(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->openGroup(_return);
    }
    ifaces_[i]->openGroup(_return);
    return;
  }

  void closeGroup() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->closeGroup();
    }
    ifaces_[i]->closeGroup();
  }

  void joinToGroup(const std::string& id, const bool leader) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->joinToGroup(id, leader);
    }
    ifaces_[i]->joinToGroup(id, leader);
  }

  void joinToGroupName(const std::string& id, const bool leader, const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->joinToGroupName(id, leader, name);
    }
    ifaces_[i]->joinToGroupName(id, leader, name);
  }

  bool hasGroup(const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->hasGroup(name);
    }
    return ifaces_[i]->hasGroup(name);
  }

  void destroyGroup(const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->destroyGroup(name);
    }
    ifaces_[i]->destroyGroup(name);
  }

  void destroyGroups() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->destroyGroups();
    }
    ifaces_[i]->destroyGroups();
  }

  int8_t getProtocol() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getProtocol();
    }
    return ifaces_[i]->getProtocol();
  }

  void getPartitions(std::vector<std::string> & _return, const int8_t protocol) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getPartitions(_return, protocol);
    }
    ifaces_[i]->getPartitions(_return, protocol);
    return;
  }

  void getPartitions2(std::vector<std::string> & _return, const int8_t protocol, const int64_t minPartitions) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getPartitions2(_return, protocol, minPartitions);
    }
    ifaces_[i]->getPartitions2(_return, protocol, minPartitions);
    return;
  }

  void setPartitions(const std::vector<std::string> & partitions) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setPartitions(partitions);
    }
    ifaces_[i]->setPartitions(partitions);
  }

  void setPartitions2(const std::vector<std::string> & partitions, const  ::ignis::rpc::ISource& src) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setPartitions2(partitions, src);
    }
    ifaces_[i]->setPartitions2(partitions, src);
  }

  void newEmptyPartitions(const int64_t n) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newEmptyPartitions(n);
    }
    ifaces_[i]->newEmptyPartitions(n);
  }

  void newEmptyPartitions2(const int64_t n, const  ::ignis::rpc::ISource& src) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newEmptyPartitions2(n, src);
    }
    ifaces_[i]->newEmptyPartitions2(n, src);
  }

  void driverGather(const std::string& group, const  ::ignis::rpc::ISource& src) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->driverGather(group, src);
    }
    ifaces_[i]->driverGather(group, src);
  }

  void driverGather0(const std::string& group, const  ::ignis::rpc::ISource& src) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->driverGather0(group, src);
    }
    ifaces_[i]->driverGather0(group, src);
  }

  void driverScatter(const std::string& group, const int64_t partitions) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->driverScatter(group, partitions);
    }
    ifaces_[i]->driverScatter(group, partitions);
  }

  void driverScatter3(const std::string& group, const int64_t partitions, const  ::ignis::rpc::ISource& src) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->driverScatter3(group, partitions, src);
    }
    ifaces_[i]->driverScatter3(group, partitions, src);
  }

  int32_t enableMultithreading(const std::string& group) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->enableMultithreading(group);
    }
    return ifaces_[i]->enableMultithreading(group);
  }

  void send(const std::string& group, const int64_t partition, const int64_t dest, const int32_t thread) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->send(group, partition, dest, thread);
    }
    ifaces_[i]->send(group, partition, dest, thread);
  }

  void recv(const std::string& group, const int64_t partition, const int64_t source, const int32_t thread) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->recv(group, partition, source, thread);
    }
    ifaces_[i]->recv(group, partition, source, thread);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class ICommModuleConcurrentClient : virtual public ICommModuleIf {
 public:
  ICommModuleConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(prot);
  }
  ICommModuleConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) : sync_(sync)
{
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void openGroup(std::string& _return);
  int32_t send_openGroup();
  void recv_openGroup(std::string& _return, const int32_t seqid);
  void closeGroup();
  int32_t send_closeGroup();
  void recv_closeGroup(const int32_t seqid);
  void joinToGroup(const std::string& id, const bool leader);
  int32_t send_joinToGroup(const std::string& id, const bool leader);
  void recv_joinToGroup(const int32_t seqid);
  void joinToGroupName(const std::string& id, const bool leader, const std::string& name);
  int32_t send_joinToGroupName(const std::string& id, const bool leader, const std::string& name);
  void recv_joinToGroupName(const int32_t seqid);
  bool hasGroup(const std::string& name);
  int32_t send_hasGroup(const std::string& name);
  bool recv_hasGroup(const int32_t seqid);
  void destroyGroup(const std::string& name);
  int32_t send_destroyGroup(const std::string& name);
  void recv_destroyGroup(const int32_t seqid);
  void destroyGroups();
  int32_t send_destroyGroups();
  void recv_destroyGroups(const int32_t seqid);
  int8_t getProtocol();
  int32_t send_getProtocol();
  int8_t recv_getProtocol(const int32_t seqid);
  void getPartitions(std::vector<std::string> & _return, const int8_t protocol);
  int32_t send_getPartitions(const int8_t protocol);
  void recv_getPartitions(std::vector<std::string> & _return, const int32_t seqid);
  void getPartitions2(std::vector<std::string> & _return, const int8_t protocol, const int64_t minPartitions);
  int32_t send_getPartitions2(const int8_t protocol, const int64_t minPartitions);
  void recv_getPartitions2(std::vector<std::string> & _return, const int32_t seqid);
  void setPartitions(const std::vector<std::string> & partitions);
  int32_t send_setPartitions(const std::vector<std::string> & partitions);
  void recv_setPartitions(const int32_t seqid);
  void setPartitions2(const std::vector<std::string> & partitions, const  ::ignis::rpc::ISource& src);
  int32_t send_setPartitions2(const std::vector<std::string> & partitions, const  ::ignis::rpc::ISource& src);
  void recv_setPartitions2(const int32_t seqid);
  void newEmptyPartitions(const int64_t n);
  int32_t send_newEmptyPartitions(const int64_t n);
  void recv_newEmptyPartitions(const int32_t seqid);
  void newEmptyPartitions2(const int64_t n, const  ::ignis::rpc::ISource& src);
  int32_t send_newEmptyPartitions2(const int64_t n, const  ::ignis::rpc::ISource& src);
  void recv_newEmptyPartitions2(const int32_t seqid);
  void driverGather(const std::string& group, const  ::ignis::rpc::ISource& src);
  int32_t send_driverGather(const std::string& group, const  ::ignis::rpc::ISource& src);
  void recv_driverGather(const int32_t seqid);
  void driverGather0(const std::string& group, const  ::ignis::rpc::ISource& src);
  int32_t send_driverGather0(const std::string& group, const  ::ignis::rpc::ISource& src);
  void recv_driverGather0(const int32_t seqid);
  void driverScatter(const std::string& group, const int64_t partitions);
  int32_t send_driverScatter(const std::string& group, const int64_t partitions);
  void recv_driverScatter(const int32_t seqid);
  void driverScatter3(const std::string& group, const int64_t partitions, const  ::ignis::rpc::ISource& src);
  int32_t send_driverScatter3(const std::string& group, const int64_t partitions, const  ::ignis::rpc::ISource& src);
  void recv_driverScatter3(const int32_t seqid);
  int32_t enableMultithreading(const std::string& group);
  int32_t send_enableMultithreading(const std::string& group);
  int32_t recv_enableMultithreading(const int32_t seqid);
  void send(const std::string& group, const int64_t partition, const int64_t dest, const int32_t thread);
  int32_t send_send(const std::string& group, const int64_t partition, const int64_t dest, const int32_t thread);
  void recv_send(const int32_t seqid);
  void recv(const std::string& group, const int64_t partition, const int64_t source, const int32_t thread);
  int32_t send_recv(const std::string& group, const int64_t partition, const int64_t source, const int32_t thread);
  void recv_recv(const int32_t seqid);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}}} // namespace

#endif
